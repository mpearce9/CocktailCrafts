{"ast":null,"code":"// Styles\nimport \"../../../src/components/VProgressCircular/VProgressCircular.sass\"; // Directives\n\nimport intersect from '../../directives/intersect'; // Mixins\n\nimport Colorable from '../../mixins/colorable'; // Utils\n\nimport { convertToUnit } from '../../util/helpers';\n/* @vue/component */\n\nexport default Colorable.extend({\n  name: 'v-progress-circular',\n  directives: {\n    intersect: intersect\n  },\n  props: {\n    button: Boolean,\n    indeterminate: Boolean,\n    rotate: {\n      type: [Number, String],\n      \"default\": 0\n    },\n    size: {\n      type: [Number, String],\n      \"default\": 32\n    },\n    width: {\n      type: [Number, String],\n      \"default\": 4\n    },\n    value: {\n      type: [Number, String],\n      \"default\": 0\n    }\n  },\n  data: function data() {\n    return {\n      radius: 20,\n      isVisible: true\n    };\n  },\n  computed: {\n    calculatedSize: function calculatedSize() {\n      return Number(this.size) + (this.button ? 8 : 0);\n    },\n    circumference: function circumference() {\n      return 2 * Math.PI * this.radius;\n    },\n    classes: function classes() {\n      return {\n        'v-progress-circular--visible': this.isVisible,\n        'v-progress-circular--indeterminate': this.indeterminate,\n        'v-progress-circular--button': this.button\n      };\n    },\n    normalizedValue: function normalizedValue() {\n      if (this.value < 0) {\n        return 0;\n      }\n\n      if (this.value > 100) {\n        return 100;\n      }\n\n      return parseFloat(this.value);\n    },\n    strokeDashArray: function strokeDashArray() {\n      return Math.round(this.circumference * 1000) / 1000;\n    },\n    strokeDashOffset: function strokeDashOffset() {\n      return (100 - this.normalizedValue) / 100 * this.circumference + 'px';\n    },\n    strokeWidth: function strokeWidth() {\n      return Number(this.width) / +this.size * this.viewBoxSize * 2;\n    },\n    styles: function styles() {\n      return {\n        height: convertToUnit(this.calculatedSize),\n        width: convertToUnit(this.calculatedSize)\n      };\n    },\n    svgStyles: function svgStyles() {\n      return {\n        transform: \"rotate(\".concat(Number(this.rotate), \"deg)\")\n      };\n    },\n    viewBoxSize: function viewBoxSize() {\n      return this.radius / (1 - Number(this.width) / +this.size);\n    }\n  },\n  methods: {\n    genCircle: function genCircle(name, offset) {\n      return this.$createElement('circle', {\n        \"class\": \"v-progress-circular__\".concat(name),\n        attrs: {\n          fill: 'transparent',\n          cx: 2 * this.viewBoxSize,\n          cy: 2 * this.viewBoxSize,\n          r: this.radius,\n          'stroke-width': this.strokeWidth,\n          'stroke-dasharray': this.strokeDashArray,\n          'stroke-dashoffset': offset\n        }\n      });\n    },\n    genSvg: function genSvg() {\n      var children = [this.indeterminate || this.genCircle('underlay', 0), this.genCircle('overlay', this.strokeDashOffset)];\n      return this.$createElement('svg', {\n        style: this.svgStyles,\n        attrs: {\n          xmlns: 'http://www.w3.org/2000/svg',\n          viewBox: \"\".concat(this.viewBoxSize, \" \").concat(this.viewBoxSize, \" \").concat(2 * this.viewBoxSize, \" \").concat(2 * this.viewBoxSize)\n        }\n      }, children);\n    },\n    genInfo: function genInfo() {\n      return this.$createElement('div', {\n        staticClass: 'v-progress-circular__info'\n      }, this.$slots[\"default\"]);\n    },\n    onObserve: function onObserve(entries, observer, isIntersecting) {\n      this.isVisible = isIntersecting;\n    }\n  },\n  render: function render(h) {\n    return h('div', this.setTextColor(this.color, {\n      staticClass: 'v-progress-circular',\n      attrs: {\n        role: 'progressbar',\n        'aria-valuemin': 0,\n        'aria-valuemax': 100,\n        'aria-valuenow': this.indeterminate ? undefined : this.normalizedValue\n      },\n      \"class\": this.classes,\n      directives: [{\n        name: 'intersect',\n        value: this.onObserve\n      }],\n      style: this.styles,\n      on: this.$listeners\n    }), [this.genSvg(), this.genInfo()]);\n  }\n});","map":{"version":3,"mappings":"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","names":["intersect","Colorable","convertToUnit","extend","name","directives","props","button","Boolean","indeterminate","rotate","type","Number","String","size","width","value","data","radius","isVisible","computed","calculatedSize","circumference","Math","PI","classes","normalizedValue","parseFloat","strokeDashArray","round","strokeDashOffset","strokeWidth","viewBoxSize","styles","height","svgStyles","transform","methods","genCircle","offset","$createElement","attrs","fill","cx","cy","r","genSvg","children","style","xmlns","viewBox","genInfo","staticClass","$slots","onObserve","entries","observer","isIntersecting","render","h","setTextColor","color","role","undefined","on","$listeners"],"sourceRoot":"","sources":["../../../src/components/VProgressCircular/VProgressCircular.ts"],"sourcesContent":["// Styles\nimport './VProgressCircular.sass'\n\n// Directives\nimport intersect from '../../directives/intersect'\n\n// Mixins\nimport Colorable from '../../mixins/colorable'\n\n// Utils\nimport { convertToUnit } from '../../util/helpers'\n\n// Types\nimport { VNode, VNodeChildren } from 'vue'\n\n/* @vue/component */\nexport default Colorable.extend({\n  name: 'v-progress-circular',\n\n  directives: { intersect },\n\n  props: {\n    button: Boolean,\n    indeterminate: Boolean,\n    rotate: {\n      type: [Number, String],\n      default: 0,\n    },\n    size: {\n      type: [Number, String],\n      default: 32,\n    },\n    width: {\n      type: [Number, String],\n      default: 4,\n    },\n    value: {\n      type: [Number, String],\n      default: 0,\n    },\n  },\n\n  data: () => ({\n    radius: 20,\n    isVisible: true,\n  }),\n\n  computed: {\n    calculatedSize (): number {\n      return Number(this.size) + (this.button ? 8 : 0)\n    },\n\n    circumference (): number {\n      return 2 * Math.PI * this.radius\n    },\n\n    classes (): object {\n      return {\n        'v-progress-circular--visible': this.isVisible,\n        'v-progress-circular--indeterminate': this.indeterminate,\n        'v-progress-circular--button': this.button,\n      }\n    },\n\n    normalizedValue (): number {\n      if (this.value < 0) {\n        return 0\n      }\n\n      if (this.value > 100) {\n        return 100\n      }\n\n      return parseFloat(this.value)\n    },\n\n    strokeDashArray (): number {\n      return Math.round(this.circumference * 1000) / 1000\n    },\n\n    strokeDashOffset (): string {\n      return ((100 - this.normalizedValue) / 100) * this.circumference + 'px'\n    },\n\n    strokeWidth (): number {\n      return Number(this.width) / +this.size * this.viewBoxSize * 2\n    },\n\n    styles (): object {\n      return {\n        height: convertToUnit(this.calculatedSize),\n        width: convertToUnit(this.calculatedSize),\n      }\n    },\n\n    svgStyles (): object {\n      return {\n        transform: `rotate(${Number(this.rotate)}deg)`,\n      }\n    },\n\n    viewBoxSize (): number {\n      return this.radius / (1 - Number(this.width) / +this.size)\n    },\n  },\n\n  methods: {\n    genCircle (name: string, offset: string | number): VNode {\n      return this.$createElement('circle', {\n        class: `v-progress-circular__${name}`,\n        attrs: {\n          fill: 'transparent',\n          cx: 2 * this.viewBoxSize,\n          cy: 2 * this.viewBoxSize,\n          r: this.radius,\n          'stroke-width': this.strokeWidth,\n          'stroke-dasharray': this.strokeDashArray,\n          'stroke-dashoffset': offset,\n        },\n      })\n    },\n    genSvg (): VNode {\n      const children = [\n        this.indeterminate || this.genCircle('underlay', 0),\n        this.genCircle('overlay', this.strokeDashOffset),\n      ] as VNodeChildren\n\n      return this.$createElement('svg', {\n        style: this.svgStyles,\n        attrs: {\n          xmlns: 'http://www.w3.org/2000/svg',\n          viewBox: `${this.viewBoxSize} ${this.viewBoxSize} ${2 * this.viewBoxSize} ${2 * this.viewBoxSize}`,\n        },\n      }, children)\n    },\n    genInfo (): VNode {\n      return this.$createElement('div', {\n        staticClass: 'v-progress-circular__info',\n      }, this.$slots.default)\n    },\n    onObserve (entries: IntersectionObserverEntry[], observer: IntersectionObserver, isIntersecting: boolean) {\n      this.isVisible = isIntersecting\n    },\n  },\n\n  render (h): VNode {\n    return h('div', this.setTextColor(this.color, {\n      staticClass: 'v-progress-circular',\n      attrs: {\n        role: 'progressbar',\n        'aria-valuemin': 0,\n        'aria-valuemax': 100,\n        'aria-valuenow': this.indeterminate ? undefined : this.normalizedValue,\n      },\n      class: this.classes,\n      directives: [{\n        name: 'intersect',\n        value: this.onObserve,\n      }],\n      style: this.styles,\n      on: this.$listeners,\n    }), [\n      this.genSvg(),\n      this.genInfo(),\n    ])\n  },\n})\n"]},"metadata":{},"sourceType":"module"}